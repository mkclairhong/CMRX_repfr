---

title: Data Preparation


keywords: fastai
sidebar: home_sidebar



nb_path: "02_Data_Preparation.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 02_Data_Preparation.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Whether working with simulated data or the real deal, it has to be represented in a standardized way to enable interchangeable use of library functions.</p>
<p>In general, we prepare data in two formats:</p>
<ul>
<li><p><strong>Psifr-Format</strong>. We use or modify code from the Psifr library for analysis of free recall data. Documentation of the data format expected by the library is provided in detail <a href="https://psifr.readthedocs.io/en/latest/guide/import.html">here</a>. In particular, our data preparation code tends to import data as specified in the linked documentation and then apply <code>psifr.merge_free_recall</code> to the imported DataFrame to enable direct computation of key summary statistics using other functions in the library.</p>
</li>
<li><p><strong>Trials Array</strong>. The dataframes used by Psifr to prepare visualizes are useful for that purpose, but aren't ideal for the numerical calculations that often underlie tasks like model fitting. In prepared <code>trials</code> arrays, each row corresponds to a unique trial that some subject performed for the study, while each entry corresponds to a recall event. Each positive integer refers to a unique item within the context of that trial, while 0 can be safely coded as recall termination, and negative integers track unique intrusions (though we normally exclude those during data preparation).</p>
</li>
</ul>
<p>Our data preparation functions also tend to output associated metadata - e.g. list lengths, subject indices, condition vectors, and so on - useful for ensuring the correctness or speed of functions using them, or just for selecting subsets of the dataset for individualized analysis. I tend to add these in a haphazard way - when I realize I might use them! By including them in a dataset's associated preparation function, I avoid having to reimplement an extraction routine myself later on.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Murdock1962-Dataset">Murdock1962 Dataset<a class="anchor-link" href="#Murdock1962-Dataset"> </a></h2><p>This dataset doesn't have any item repetitions, but could be useful for sanity checks and whatnot.</p>
<p>Our data structure associated with Murdock (1962) has three <code>LL</code> structures that each seem to correspond to a different data set with different list lengths.  Inside
each structure is:</p>
<ul>
<li><code>recalls</code> with 1200 rows and 50 columns. Each row presumably represents a subject, and each column seems to
correspond to a recall position, with -1 coded for intrusions. <code>MurdData_clean.mat</code> probably doesn't have these
intrusions coded at all.</li>
<li><code>listlength</code> is an integer indicating how long the studied list is.</li>
<li><code>subject</code> is a 1200x1 vector coding the identities of each subject for each row. Each subject seems to get 80 rows a
piece. He really got that much data for each subject?</li>
<li><code>session</code> similarly codes the index of the session under consideration, and it's always 1 in this case.</li>
<li><code>presitemnumbers</code> probably codes the number associated with each item. Is just its presentation index.</li>
</ul>
<p>We'll enable selection of relevant information from these structures based on which <code>LL</code> structure we're interested in using a <code>dataset_index</code> parameter.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">murd_trials</span><span class="p">,</span> <span class="n">murd_events</span><span class="p">,</span> <span class="n">murd_length</span> <span class="o">=</span> <span class="n">prepare_murddata</span><span class="p">(</span>
    <span class="s1">&#39;../../data/MurdData_clean.mat&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">murd_events</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Lohnas2014-Dataset">Lohnas2014 Dataset<a class="anchor-link" href="#Lohnas2014-Dataset"> </a></h2><blockquote><p>Siegel, L. L., &amp; Kahana, M. J. (2014). A retrieved context account of spacing and repetition effects in free recall. Journal of Experimental Psychology:Learning, Memory, and Cognition, 40(3), 755.</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Across 4 sessions, 35 subjects performed delayed free recall of 48 lists. Subjects were University of Pennsylvania undergraduates, graduates and staff, age 18-32. List items were drawn from a pool of 1638 words taken from the University of South Florida free association norms (Nelson, McEvoy, &amp; Schreiber, 2004; Steyvers, Shiffrin, &amp; Nelson, 2004, available at <a href="http://memory.psych.upenn.edu/files/wordpools/PEERS_wordpool.zip">http://memory.psych.upenn.edu/files/wordpools/PEERS_wordpool.zip</a>). Within each session, words were drawn without replacement. Words could repeat across sessions so long as they did not repeat in two successive sessions. Words were also selected to ensure that no strong semantic associates co-occurred in a given list (i.e., the semantic relatedness between any two words on a given list, as determined using WAS (Steyvers et al., 2004), did not exceed a threshold value of 0.55).</p>
<p>Subjects encountered four different types of lists:</p>
<ol>
<li>Control lists that contained all once-presented items;  </li>
<li>pure massed lists containing all twice-presented items; </li>
<li>pure spaced lists consisting of items presented twice at lags 1-8, where lag is defined as the number of intervening items between a repeated item's presentations; </li>
<li>mixed lists consisting of once presented, massed and spaced items. Within each session, subjects encountered three lists of each of these four types. </li>
</ol>
<p>In each list there were 40 presentation positions, such that in the control lists each position was occupied by a unique list item, and in the pure massed and pure spaced lists, 20 unique words were presented twice to occupy the 40 positions. In the mixed lists 28 once-presented and six twice-presented words occupied the 40 positions. In the pure spaced lists, spacings of repeated items were chosen so that each of the lags 1-8 occurred with equal probability. In the mixed lists, massed repetitions (lag=0) and spaced repetitions (lags 1-8) were chosen such that each of the 9 lags of 0-8 were used exactly twice within each session. The order of presentation for the different list types was randomized within each session. For the first session, the first four lists were chosen so that each list type was presented exactly once. An experimenter sat in with the subject for these first four lists, though no subject had difficulty understanding the task.</p>
<p>The data for this experiment is stored in <code>data/repFR.mat</code>. We define a unique <code>prepare_repetition_data</code> function to build structures from the dataset that works with our existing data analysis and fitting functions.</p>
<p>Like in <code>prepare_murd_data</code>, we need list lengths, a data frame for visualizations with psifir, and a trials array encoding recall events as sequences of presentation positions. But we'll also need an additional array tracking presentation order, too.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="prepare_repdata" class="doc_header"><code>prepare_repdata</code><a href="https://github.com/Solve-Memory/repfr/tree/{branch}/repfr/datasets.py#L71" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>prepare_repdata</code>(<strong><code>path</code></strong>)</p>
</blockquote>
<p>Prepares data formatted like <code>data/repFR.mat</code> for fitting.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">trials</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">list_length</span><span class="p">,</span> <span class="n">presentations</span><span class="p">,</span> <span class="n">list_types</span><span class="p">,</span> <span class="n">rep_data</span><span class="p">,</span> <span class="n">subjects</span> <span class="o">=</span> <span class="n">prepare_repdata</span><span class="p">(</span>
    <span class="s1">&#39;data/repFR.mat&#39;</span><span class="p">)</span>

<span class="n">events</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>subject</th>
      <th>list</th>
      <th>item</th>
      <th>input</th>
      <th>output</th>
      <th>study</th>
      <th>recall</th>
      <th>repeat</th>
      <th>intrusion</th>
      <th>condition</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1.0</td>
      <td>True</td>
      <td>True</td>
      <td>0</td>
      <td>False</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>2</td>
      <td>2.0</td>
      <td>True</td>
      <td>True</td>
      <td>0</td>
      <td>False</td>
      <td>4</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>3.0</td>
      <td>True</td>
      <td>True</td>
      <td>0</td>
      <td>False</td>
      <td>4</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>1</td>
      <td>3</td>
      <td>4</td>
      <td>4.0</td>
      <td>True</td>
      <td>True</td>
      <td>0</td>
      <td>False</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>1</td>
      <td>4</td>
      <td>5</td>
      <td>5.0</td>
      <td>True</td>
      <td>True</td>
      <td>0</td>
      <td>False</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Simulated-Datasets">Simulated Datasets<a class="anchor-link" href="#Simulated-Datasets"> </a></h2><p>The approach for creating simulated datasets is to initialize a model with specified parameters and experience sequences and then populate a psifr-formatted array with the outcomes of performing <code>free recall</code>.</p>
<p>The <a href="/repfr/Data_Preparation.html#simulate_data"><code>simulate_data</code></a> function below presumes each item is just presented once and that a model has already been initialized, and is better for quick baseline characterization of model performance. Datasets with item repetitions during presentation violate this premise; a more unique function is normally necessary for simulating these models in a performant way.</p>
<p>Since model simulation this way has always directly led to visualization in work done so far, a corresponding <code>trials</code> array is not produced.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="simulate_data" class="doc_header"><code>simulate_data</code><a href="https://github.com/Solve-Memory/repfr/tree/{branch}/repfr/datasets.py#L141" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>simulate_data</code>(<strong><code>model</code></strong>, <strong><code>experiment_count</code></strong>, <strong><code>first_recall_item</code></strong>=<em><code>None</code></em>)</p>
</blockquote>
<p>Initialize a model with specified parameters and experience sequences and
then populate a psifr-formatted dataframe with the outcomes of performing <code>free recall</code>.</p>
<p><strong>Required model attributes</strong>:</p>
<ul>
<li>item_count: specifies number of items encoded into memory</li>
<li>context: vector representing an internal contextual state</li>
<li>experience: adding a new trace to the memory model</li>
<li>free_recall: function that freely recalls a given number of items or until recall stops</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

</div>
 

