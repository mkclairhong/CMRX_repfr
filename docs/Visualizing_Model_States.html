---

title: Visualizing Model States


keywords: fastai
sidebar: home_sidebar

summary: "quick exploratory analysis of model states at arbitrary points along simulation"
description: "quick exploratory analysis of model states at arbitrary points along simulation"
nb_path: "01_Visualizing_Model_States.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 01_Visualizing_Model_States.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We often simulate a simple free recall experiment and visualize model states throughout to explore their capacity to
exhibit classical patterns of primacy, recency, and temporal contiguity. Any arbitrary configuration of parameters can
be specified for the model, including an <code>experiment_count</code>, determining the number of simulations with the given
parameters.</p>
<p>In each experiment:</p>
<ol>
<li>A specified number of unique items are each experienced once,</li>
<li>Context is momentarily drifted toward its pre-experimental state, and</li>
<li>The model freely recalls items until it stops, with retrieval of previously experienced items disallowed.</li>
</ol>
<p>To visualize model state, we add to our <code>model_analysis</code> submodule three basic categories of visualizations. To
visualize model state throughout encoding, we track the state of <code>context</code> and the amount of <code>support</code> for recall of
each item based on contextual state. We also prepare a visualization of the final state of <code>memory</code> once encoding is
finished. To visualize model state throughout retrieval, we similarly track <code>context</code> and <code>support</code> at each step of
recall. An additional visualization makes clearer the distribution of outcome probabilities at a particular index of
recall (e.g. after a second item has been recalled).</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Demo-Parameters">Demo Parameters<a class="anchor-link" href="#Demo-Parameters"> </a></h2><p>For a demo of these functions, you can specify default model parameters (or even alter which model is considered) in the following code cell:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># this demo if it supports the same functions</span>
<span class="kn">from</span> <span class="nn">repfr.models</span> <span class="kn">import</span> <span class="n">DefaultCMR</span> <span class="k">as</span> <span class="n">CMR</span>

<span class="c1"># entries and values in this dict will be passed as model parameters</span>
<span class="n">cmr_parameters</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Plotting-Encoding-States">Plotting Encoding States<a class="anchor-link" href="#Plotting-Encoding-States"> </a></h2><p>First we create simulations and visualizations to track model state throughout encoding of new memories.</p>
<p>To do this,we produce two parallel functions, <a href="/repfr/Visualizing_Model_States.html#encoding_states"><code>encoding_states</code></a> and <a href="/repfr/Visualizing_Model_States.html#plot_states"><code>plot_states</code></a> that collect and visualize encoding states, respectively.</p>
<p>An additional wrapper function called <a href="/repfr/Visualizing_Model_States.html#encoding_visualizations"><code>encoding_visualizations</code></a> plots these states in addition to the
final overall state of model memory.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="encoding_states" class="doc_header"><code>encoding_states</code><a href="https://github.com/Solve-Memory/repfr/tree/{branch}/repfr/model_analysis.py#L11" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>encoding_states</code>(<strong><code>model</code></strong>)</p>
</blockquote>
<p>Tracks state of context, and item supports across encoding. Model is also advanced to a state of fully encoded
memories.</p>
<p><strong>Required model attributes</strong>:</p>
<ul>
<li>item_count: specifies number of items encoded into memory</li>
<li>context: vector representing an internal contextual state</li>
<li>experience: adding a new trace to the memory model</li>
<li>activations: function returning item activations given a vector probe</li>
<li>outcome_probabilities: function returning item supports given a set of activations</li>
</ul>
<p><strong>Returns</strong> array representations of context and support for retrieval of each item at each increment of item
encoding. Each has shape model.item_count by model.item_count + 1.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="plot_states" class="doc_header"><code>plot_states</code><a href="https://github.com/Solve-Memory/repfr/tree/{branch}/repfr/model_analysis.py#L52" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>plot_states</code>(<strong><code>matrix</code></strong>, <strong><code>title</code></strong>, <strong><code>figsize</code></strong>=<em><code>(15, 15)</code></em>, <strong><code>savefig</code></strong>=<em><code>False</code></em>)</p>
</blockquote>
<p>Plots an array of model states as a value-annotated heatmap with an arbitrary title.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li>matrix: an array of model states, ideally with columns representing unique feature indices and rows
  representing unique update indices</li>
<li>title: a title for the generated plot, ideally conveying what array values represent at each entry</li>
<li>savefig: boolean deciding whether generated figure is saved (True if Yes)</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="encoding_visualizations" class="doc_header"><code>encoding_visualizations</code><a href="https://github.com/Solve-Memory/repfr/tree/{branch}/repfr/model_analysis.py#L74" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>encoding_visualizations</code>(<strong><code>model</code></strong>, <strong><code>savefig</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>Plots encoding contexts, encoding supports as heatmaps.</p>
<p><strong>Required model attributes</strong>:</p>
<ul>
<li>item_count: specifies number of items encoded into memory</li>
<li>context: vector representing an internal contextual state</li>
<li>experience: adding a new trace to the memory model</li>
<li>activations: function returning item activations given a vector probe</li>
<li>outcome_probabilities: function returning item supports given a set of activations</li>
<li>memory: a unitary representation of the current state of memory</li>
</ul>
<p><strong>Also</strong> requires savefig:  boolean deciding if generated figure is saved</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Demo">Demo<a class="anchor-link" href="#Demo"> </a></h3>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">CMR</span><span class="p">(</span><span class="o">**</span><span class="n">cmr_parameters</span><span class="p">)</span>
<span class="n">encoding_visualizations</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="/repfr/Visualizing_Model_States.html#plot_states"><code>plot_states</code></a> is flexible enough to visualize other model representations, too:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">CMR</span><span class="p">(</span><span class="o">**</span><span class="n">parameters</span><span class="p">)</span>
<span class="n">encoding_states</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">plot_states</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">mfc</span><span class="p">,</span> <span class="s1">&#39;CMR Mfc&#39;</span><span class="p">)</span>
<span class="n">plot_states</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">mcf</span><span class="p">,</span> <span class="s1">&#39;CMR Mcf&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Plotting-Retrieval-States">Plotting Retrieval States<a class="anchor-link" href="#Plotting-Retrieval-States"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Tracking model state across each step of retrieval. Since retrieval stochastic, these values change with each random seed. An additional optional parameter <code>first_recall_item</code> can control which item is recalled first by the model (<code>0</code> denotes termination of recall while actual items are 1-indexed); it is useful for testing hypotheses about model dynamics during recall. We leave the parameter set at <code>None</code>, for now, indicating no controlled first recall.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="retrieval_states" class="doc_header"><code>retrieval_states</code><a href="https://github.com/Solve-Memory/repfr/tree/{branch}/repfr/model_analysis.py#L97" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>retrieval_states</code>(<strong><code>model</code></strong>, <strong><code>first_recall_item</code></strong>=<em><code>None</code></em>)</p>
</blockquote>
<p>Tracks state of context, and item supports across retrieval. Model is also advanced into a state of
completed free recall.</p>
<p><strong>Required model attributes</strong>:</p>
<ul>
<li>item_count: specifies number of items encoded into memory</li>
<li>context: vector representing an internal contextual state</li>
<li>experience: adding a new trace to the memory model</li>
<li>activations: function returning item activations given a vector probe</li>
<li>outcome_probabilities: function returning item supports given a set of activations</li>
<li>free_recall: function that freely recalls a given number of items or until recall stops</li>
<li>state: indicates whether model is encoding or engaged in recall with a string</li>
</ul>
<p><strong>Also</strong> optionally uses first_recall_item: can specify an item for first recall</p>
<p><strong>Returns</strong> array representations of context and support for retrieval of each item at each increment of item
retrieval. Also returns recall train associated with simulation.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="outcome_probs_at_index" class="doc_header"><code>outcome_probs_at_index</code><a href="https://github.com/Solve-Memory/repfr/tree/{branch}/repfr/model_analysis.py#L148" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>outcome_probs_at_index</code>(<strong><code>model</code></strong>, <strong><code>support_index_to_plot</code></strong>=<em><code>1</code></em>, <strong><code>savefig</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>Plots outcome probability distribution at a specific index of free recall.</p>
<p><strong>Required model attributes</strong>:</p>
<ul>
<li>item_count: specifies number of items encoded into memory</li>
<li>context: vector representing an internal contextual state</li>
<li>experience: adding a new trace to the memory model</li>
<li>activations: function returning item activations given a vector probe</li>
<li>outcome_probabilities: function returning item supports given a set of activations</li>
<li>free_recall: function that freely recalls a given number of items or until recall stops</li>
<li>state: indicates whether model is encoding or engaged in recall with a string</li>
</ul>
<p><strong>Other arguments</strong>:</p>
<ul>
<li>support_index_to_plot: index of retrieval to plot</li>
<li>savefig: whether to save or display the figure of interest</li>
</ul>
<p><strong>Generates</strong> a plot of outcome probabilities as a line graph. Also returns vector representation of the
generated probabilities.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="retrieval_visualizations" class="doc_header"><code>retrieval_visualizations</code><a href="https://github.com/Solve-Memory/repfr/tree/{branch}/repfr/model_analysis.py#L179" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>retrieval_visualizations</code>(<strong><code>model</code></strong>, <strong><code>savefig</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>Plots incremental retrieval contexts and supports, as heatmaps, and prints recalled items.</p>
<p><strong>Required model attributes</strong>:</p>
<ul>
<li>item_count: specifies number of items encoded into memory</li>
<li>context: vector representing an internal contextual state</li>
<li>experience: adding a new trace to the memory model</li>
<li>activations: function returning item activations given a vector probe</li>
<li>outcome_probabilities: function returning item supports given a set of activations</li>
</ul>
<p><strong>Also</strong> uses savefig: boolean deciding whether figures are saved (True) or displayed</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Demo">Demo<a class="anchor-link" href="#Demo"> </a></h3>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">CMR</span><span class="p">(</span><span class="o">**</span><span class="n">cmr_parameters</span><span class="p">)</span>
<span class="n">retrieval_visualizations</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

